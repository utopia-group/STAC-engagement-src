/*
 * Decompiled with CFR 0_117.
 */
package com.ainfosec.MalwareAnalyzer;

import com.ainfosec.MalwareAnalyzer.Dasm;
import com.ainfosec.MalwareAnalyzer.Sample;

public class Analysis {
    private static int byte_average_threshold = 95;
    private static double byte_entropy_threshold = 6.55;

    public static boolean is_packed(int[] fv) {
        int byte_average = Analysis.compute_average_byte(fv);
        double byte_entropy = Analysis.compute_byte_entropy(fv);
        if (byte_average > byte_average_threshold && byte_entropy > byte_entropy_threshold) {
            return true;
        }
        return false;
    }

    private static int compute_average_byte(int[] fv) {
        return Analysis.compute_average_byte_helper(fv, 0, 0, 0);
    }

    private static int compute_average_byte_helper(int[] fv, int count_acc, int sum_acc, int step) {
        if (step > 255) {
            return sum_acc / count_acc;
        }
        int new_count = count_acc + fv[step];
        int new_sum = sum_acc + step * fv[step];
        return Analysis.compute_average_byte_helper(fv, new_count, new_sum, step + 1);
    }

    private static double compute_byte_entropy(int[] fv) {
        int count_of_bytes = Analysis.count_bytes(fv);
        return Analysis.compute_byte_entropy_helper(fv, count_of_bytes, 0.0, 0);
    }

    private static double compute_byte_entropy_helper(int[] fv, int byte_count, double ent_acc, int step) {
        double new_ent;
        if (step > 255) {
            return - ent_acc;
        }
        if (fv[step] > 0) {
            double prob = (double)fv[step] / (double)byte_count;
            new_ent = ent_acc + prob * (Math.log(prob) / Math.log(2.0));
        } else {
            new_ent = ent_acc;
        }
        return Analysis.compute_byte_entropy_helper(fv, byte_count, new_ent, step + 1);
    }

    private static int count_bytes(int[] fv) {
        return Analysis.count_bytes_helper(fv, 0, 0);
    }

    private static int count_bytes_helper(int[] fv, int count_acc, int step) {
        if (step > 255) {
            return count_acc;
        }
        return Analysis.count_bytes_helper(fv, count_acc + fv[step], step + 1);
    }

    public static double compute_cosine_similarity(Sample s1, Sample s2) {
        return Analysis.compute_cosine_similarity_helper(s1.get_fv(), s2.get_fv(), 0, 0, 0, 0, 255);
    }

    public static double compute_cosine_similarity(Dasm s1, Dasm s2) {
        return Analysis.compute_cosine_similarity_helper(s1.getFv(), s2.getFv(), 0, 0, 0, 0, 664);
    }

    private static double compute_cosine_similarity_helper(int[] fv1, int[] fv2, long dp_acc, long fv1_sos_acc, long fv2_sos_acc, int step, int num_steps) {
        if (step > num_steps) {
            return (double)dp_acc / (Math.sqrt(fv1_sos_acc) * Math.sqrt(fv2_sos_acc));
        }
        long new_dp_acc = dp_acc + (long)fv1[step] * (long)fv2[step];
        long new_fv1_sos_acc = (long)((double)fv1_sos_acc + Math.pow(fv1[step], 2.0));
        long new_fv2_sos_acc = (long)((double)fv2_sos_acc + Math.pow(fv2[step], 2.0));
        return Analysis.compute_cosine_similarity_helper(fv1, fv2, new_dp_acc, new_fv1_sos_acc, new_fv2_sos_acc, step + 1, num_steps);
    }
}

