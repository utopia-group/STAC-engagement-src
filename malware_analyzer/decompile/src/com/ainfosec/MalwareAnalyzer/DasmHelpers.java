/*
 * Decompiled with CFR 0_117.
 */
package com.ainfosec.MalwareAnalyzer;

import com.ainfosec.MalwareAnalyzer.BasicBlock;
import com.ainfosec.MalwareAnalyzer.CFG;
import com.ainfosec.MalwareAnalyzer.Dasm;
import com.ainfosec.MalwareAnalyzer.X86;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class DasmHelpers {
    public static Dasm build_dasm(String[] lines) {
        X86.initialize();
        List<String> dasm_lines = Arrays.asList(lines);
        TreeMap<Integer, String> instruction_map = DasmHelpers.parse_instructions(dasm_lines);
        instruction_map = DasmHelpers.discard_badly_decoded_instructions(instruction_map);
        Set<Integer> eps = DasmHelpers.get_function_entrypoints(instruction_map);
        Set<CFG> cfgs = DasmHelpers.make_function_cfgs(instruction_map, eps);
        Map<String, Integer> mnem_counts = DasmHelpers.count_opcode_mnemonics(instruction_map);
        int[] fv = DasmHelpers.generate_mnemonic_feature_vector(mnem_counts);
        return new Dasm(cfgs, fv);
    }

    private static TreeMap<Integer, String> parse_instructions(List<String> dasm_lines) {
        TreeMap<Integer, String> instructions = new TreeMap<Integer, String>();
        for (String l : dasm_lines) {
            int address = 0;
            String instr_dasm = "";
            Pattern p = Pattern.compile("\\s*(?<address>[0-9a-fA-F]+):\\s+(?:[0-9a-fA-F]{2} )+\\s*(?<instr>\\S.*)");
            Matcher m = p.matcher(l);
            if (!m.matches()) continue;
            address = Integer.parseInt(m.group("address"), 16);
            instr_dasm = m.group("instr");
            instr_dasm = instr_dasm.trim().replaceAll(" +", " ");
            instructions.put(address, instr_dasm);
        }
        return instructions;
    }

    private static Set<Integer> get_function_entrypoints(Map<Integer, String> instr_map) {
        HashSet<Integer> eps = new HashSet<Integer>();
        for (String instr_dasm : instr_map.values()) {
            Pattern p = Pattern.compile("call 0x(?<targetaddr>[0-9a-zA-Z]+)");
            Matcher m = p.matcher(instr_dasm);
            if (!m.matches()) continue;
            String target = m.group("targetaddr");
            eps.add(Integer.parseInt(target, 16));
        }
        return eps;
    }

    private static TreeMap<Integer, String> discard_badly_decoded_instructions(TreeMap<Integer, String> instr_map) {
        TreeMap<Integer, String> revised = new TreeMap<Integer, String>();
        for (Map.Entry<Integer, String> entry : instr_map.entrySet()) {
            Integer addr = entry.getKey();
            String instr_dasm = entry.getValue();
            if (instr_dasm.equals("(bad)") || instr_dasm.matches("[0-9]+")) continue;
            revised.put(addr, instr_dasm);
        }
        return revised;
    }

    private static Map<String, Integer> count_opcode_mnemonics(Map<Integer, String> instr_map) {
        TreeMap<String, Integer> mnem_counts = new TreeMap<String, Integer>();
        for (String instr_dasm : instr_map.values()) {
            String mnemonic = DasmHelpers.strip_arguments(instr_dasm);
            if (mnem_counts.containsKey(mnemonic)) {
                int old_count = mnem_counts.get(mnemonic);
                mnem_counts.put(mnemonic, old_count + 1);
                continue;
            }
            mnem_counts.put(mnemonic, 1);
        }
        return mnem_counts;
    }

    private static String strip_arguments(String instruction) {
        int iend = instruction.indexOf(32);
        if (iend != -1) {
            return instruction.substring(0, iend);
        }
        return instruction;
    }

    private static String get_operand(String instruction, int operand_index) {
        int index_of_next_comma;
        if (operand_index < 0) {
            return null;
        }
        int space_count = instruction.length() - instruction.replace(" ", "").length();
        if (space_count == 0) {
            return null;
        }
        String args = instruction.substring(instruction.lastIndexOf(32) + 1).trim();
        Pattern non_enclosed_comma = Pattern.compile(",(?![^(]*\\))");
        Matcher m = non_enclosed_comma.matcher(args);
        int comma_count = 0;
        while (m.find()) {
            ++comma_count;
        }
        if (operand_index > comma_count) {
            return null;
        }
        for (int current_arg = 0; current_arg < operand_index; ++current_arg) {
            Matcher m1 = non_enclosed_comma.matcher(args);
            m1.find();
            index_of_next_comma = m1.start();
            args = args.substring(index_of_next_comma + 1);
        }
        Matcher m2 = non_enclosed_comma.matcher(args);
        if (m2.find()) {
            index_of_next_comma = m2.start();
            args = args.substring(0, index_of_next_comma);
        }
        return args;
    }

    private static boolean target_is_direct(String target) {
        return target.matches("^0x.*$");
    }

    private static Set<CFG> make_function_cfgs(TreeMap<Integer, String> instr_map, Set<Integer> entry_points) {
        HashSet<CFG> cfgs = new HashSet<CFG>();
        for (Integer ep : entry_points) {
            CFG cfg = DasmHelpers.make_function_cfg(instr_map, ep);
            cfgs.add(cfg);
        }
        return cfgs;
    }

    private static CFG make_function_cfg(TreeMap<Integer, String> instr_map, Integer entry_point) {
        CFG cfg = new CFG(entry_point);
        LinkedList<Integer> key_queue = new LinkedList<Integer>();
        key_queue.add(entry_point);
        HashSet<Integer> seen = new HashSet<Integer>();
        seen.add(entry_point);
        HashSet<Integer> assigned_instructions = new HashSet<Integer>();
        while (!key_queue.isEmpty()) {
            Integer block_ep = (Integer)key_queue.poll();
            ArrayList<Map.Entry<Integer, String>> block_instructions = new ArrayList<Map.Entry<Integer, String>>();
            HashSet<Integer> successors = new HashSet<Integer>();
            Map.Entry<Integer, String> current_instruction = instr_map.ceilingEntry(block_ep);
            while (current_instruction != null) {
                String target;
                if (assigned_instructions.contains(current_instruction.getKey())) {
                    if (block_instructions.isEmpty()) break;
                    successors.add(current_instruction.getKey());
                    break;
                }
                block_instructions.add(current_instruction);
                assigned_instructions.add(current_instruction.getKey());
                String ci_mnem = DasmHelpers.strip_arguments(current_instruction.getValue());
                if (X86.is_a_conditional_jump(ci_mnem)) {
                    Map.Entry<Integer, String> next_entry;
                    target = DasmHelpers.get_operand(current_instruction.getValue(), 0);
                    if (DasmHelpers.target_is_direct(target)) {
                        int target_int = Integer.decode(target);
                        successors.add(target_int);
                        if (!seen.contains(target_int)) {
                            key_queue.add(target_int);
                            seen.add(target_int);
                        }
                    }
                    if ((next_entry = instr_map.higherEntry(current_instruction.getKey())) == null || seen.contains(next_entry.getKey())) break;
                    key_queue.add(next_entry.getKey());
                    successors.add(next_entry.getKey());
                    seen.add(next_entry.getKey());
                    break;
                }
                if (X86.is_a_unconditional_jump(ci_mnem)) {
                    int target_int;
                    target = DasmHelpers.get_operand(current_instruction.getValue(), 0);
                    if (!DasmHelpers.target_is_direct(target) || seen.contains(target_int = Integer.decode(target).intValue())) break;
                    key_queue.add(target_int);
                    successors.add(target_int);
                    seen.add(target_int);
                    break;
                }
                if (X86.is_a_call(ci_mnem)) {
                    String target2;
                    Map.Entry<Integer, String> next_entry = instr_map.higherEntry(current_instruction.getKey());
                    if (next_entry != null && !seen.contains(next_entry.getKey())) {
                        key_queue.add(next_entry.getKey());
                        successors.add(next_entry.getKey());
                        seen.add(next_entry.getKey());
                    }
                    if (!DasmHelpers.target_is_direct(target2 = DasmHelpers.get_operand(current_instruction.getValue(), 0))) break;
                    int target_int = Integer.decode(target2);
                    cfg.add_call_target(target_int);
                    break;
                }
                if (X86.is_a_ret(ci_mnem)) break;
                current_instruction = instr_map.higherEntry(current_instruction.getKey());
            }
            if (block_instructions.isEmpty()) continue;
            cfg.add_block(new BasicBlock(block_instructions, successors));
        }
        return cfg;
    }

    private static int[] generate_mnemonic_feature_vector(Map<String, Integer> mnem_counts) {
        int[] fv = new int[665];
        for (Map.Entry<String, Integer> entry : mnem_counts.entrySet()) {
            String mnem = entry.getKey();
            int count = entry.getValue();
            Integer fv_index = X86.get_mnemonic_fv_index(mnem);
            if (fv_index == null) continue;
            fv[fv_index.intValue()] = count;
        }
        return fv;
    }
}

