/*
 * Decompiled with CFR 0_117.
 * 
 * Could not load the following classes:
 *  fi.iki.elonen.NanoHTTPD
 *  fi.iki.elonen.NanoHTTPD$IHTTPSession
 *  fi.iki.elonen.NanoHTTPD$Method
 *  fi.iki.elonen.NanoHTTPD$Response
 *  fi.iki.elonen.NanoHTTPD$Response$IStatus
 *  fi.iki.elonen.NanoHTTPD$Response$Status
 *  fi.iki.elonen.NanoHTTPD$ResponseException
 */
package com.ainfosec.MalwareAnalyzer;

import com.ainfosec.MalwareAnalyzer.BasicBlock;
import com.ainfosec.MalwareAnalyzer.CFG;
import com.ainfosec.MalwareAnalyzer.ComparisonResult;
import com.ainfosec.MalwareAnalyzer.Dasm;
import com.ainfosec.MalwareAnalyzer.DasmDatabase;
import com.ainfosec.MalwareAnalyzer.Database;
import com.ainfosec.MalwareAnalyzer.Logger;
import com.ainfosec.MalwareAnalyzer.Sample;
import fi.iki.elonen.NanoHTTPD;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URLDecoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class Server
extends NanoHTTPD {
    private static String response;

    public Server(int p) throws IOException {
        super(p);
        this.start(5000, false);
        System.out.println("Server started, running on port " + p);
        response = "";
    }

    public static String featurize(byte[] input) {
        int[] counts = new int[256];
        for (byte b : input) {
            int unsigned = b & 255;
            int[] arrn = counts;
            int n = unsigned;
            arrn[n] = arrn[n] + 1;
        }
        String fv_csv = "";
        Boolean first = true;
        for (int c : counts) {
            if (!first.booleanValue()) {
                fv_csv = fv_csv + ",";
            }
            fv_csv = fv_csv + c;
            first = false;
        }
        return fv_csv;
    }

    private static byte[] createChecksum(byte[] input) throws NoSuchAlgorithmException, IOException {
        int numRead;
        ByteArrayInputStream fis = new ByteArrayInputStream(input);
        byte[] buffer = new byte[1024];
        MessageDigest complete = MessageDigest.getInstance("MD5");
        do {
            if ((numRead = fis.read(buffer)) <= 0) continue;
            complete.update(buffer, 0, numRead);
        } while (numRead != -1);
        fis.close();
        return complete.digest();
    }

    public static String getMD5Checksum(byte[] input) throws NoSuchAlgorithmException, IOException {
        byte[] b = Server.createChecksum(input);
        String result = "";
        for (int i = 0; i < b.length; ++i) {
            result = result + Integer.toString((b[i] & 255) + 256, 16).substring(1);
        }
        return result;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {
        Logger.initialize("response.log");
        Map<String, String>  files = new HashMap<>();
        NanoHTTPD.Method method = session.getMethod();
        if (NanoHTTPD.Method.POST.equals(method)) {
            try {
                session.parseBody(files);
            }
            catch (IOException ioe) {
                return Server.newFixedLengthResponse((NanoHTTPD.Response.IStatus)NanoHTTPD.Response.Status.INTERNAL_ERROR, (String)"text/plain", (String)("SERVER INTERNAL ERROR: IOException: " + ioe.getMessage()));
            }
            catch (NanoHTTPD.ResponseException re) {
                return Server.newFixedLengthResponse((NanoHTTPD.Response.IStatus)NanoHTTPD.Response.Status.INTERNAL_ERROR, (String)"text/plain", (String)re.getMessage());
            }
            String body = session.getQueryParameterString();
            try {
                body = URLDecoder.decode(body, "UTF-8");
            }
            catch (UnsupportedEncodingException e1) {
                return Server.newFixedLengthResponse((NanoHTTPD.Response.IStatus)NanoHTTPD.Response.Status.INTERNAL_ERROR, (String)"text/plain", (String)"COULD NOT DECODE MESSAGE\n");
            }
            String[] lines = body.split("\\r?\\n");
            String var6_11 = lines[0];
            int var7_13 = -1;
            switch (var6_11.hashCode()) {
                case 107944136: {
                    if (!var6_11.equals("query")) break;
                    var7_13 = 0;
                    break;
                }
                case 96417: {
                    if (!var6_11.equals("add")) break;
                    var7_13 = 1;
                    break;
                }
                case -1236308875: {
                    if (!var6_11.equals("add_dasm")) break;
                    var7_13 = 2;
                    break;
                }
                case 693283035: {
                    if (!var6_11.equals("list_dasms")) break;
                    var7_13 = 3;
                    break;
                }
                case -2112736457: {
                    if (!var6_11.equals("get_function_entrypoints")) break;
                    var7_13 = 4;
                    break;
                }
                case -74800133: {
                    if (!var6_11.equals("get_cfg")) break;
                    var7_13 = 5;
                    break;
                }
                case -932787835: {
                    if (!var6_11.equals("query_dasms")) break;
                    var7_13 = 6;
                }
            }
            switch (var7_13) {
                case 0: {
                    if (lines.length != 2) {
                        Server.response = "Could not parse input request\n";
                          break;
                    }
                    String query_sample_md5 = lines[1];
                    Sample query_sample = Database.get_sample_by_md5(query_sample_md5);
                    if (query_sample == null) {
                        Server.response = "The supplied MD5 does not correspond to any sample in the database.\n";
                          break;
                    }
                    NavigableSet<ComparisonResult> results = Database.compute_all_similarities(query_sample_md5);
                    Server.response = "Querying " + query_sample_md5 + " " + (query_sample.is_packed() != false ? "(Packed)" : "(Not Packed)") + "\n";
                    Server.response = Server.response + "Top Five Most Similar:\n";
                    int ii = 0;
                    String feature_vector_output = "";
                    for (ComparisonResult cr : results.descendingSet()) {
                        if (cr.get_md5().equals(query_sample_md5)) continue;
                        if (ii > 4) break;
                        ++ii;
                        Sample s = Database.get_sample_by_md5(cr.get_md5());
                        String packed_status = s.is_packed() != false ? "(Packed)" : "(Not Packed)";
                        Server.response = Server.response + String.format("%s - Score: %.3f %s\n", new Object[]{cr.get_md5(), cr.get_score(), packed_status});
                        feature_vector_output = feature_vector_output + String.format("%s = {%s}\n", new Object[]{cr.get_md5(), s.serialize_fv()});
                    }
                    Server.response = Server.response + "\n" + feature_vector_output;
                    break;
                }
                case 1: {
                    if (lines.length != 3) {
                        Server.response = "Could not parse input request\nWrong number of lines for an add request.\n";
                        break;
                    }
                    String new_sample_md5 = lines[1];
                    if (new_sample_md5.length() != 32) {
                        Server.response = "Could not parse input request\nBad MD5.\n";
                        break;
                    }
                    if (Database.is_unknown(new_sample_md5)) {
                        try {
                            Database.see(new_sample_md5);
                            Sample new_sample = new Sample(lines[2]);
                            Database.add_sample(new_sample_md5, new_sample);
                        }
                        catch (Exception e) {
                            if (e instanceof NumberFormatException) {
                                Server.response = "Could not parse input request\nUnparseable data in supplied feature vector\n";
                                break;
                            }
                            if (e instanceof IllegalArgumentException) {
                                Server.response = "Could not parse input request\n" + e.toString() + "\n";
                                break;
                            }
                            StringWriter sw = new StringWriter();
                            PrintWriter pw = new PrintWriter(sw);
                            e.printStackTrace(pw);
                            Server.response = Server.response + "Could not parse input request\n" + sw.toString() + "\n";
                            break;
                        }
                        Server.response = "OK\n";
                        break;
                    }
                    Server.response = "Already known\n";
                    break;
                }
                case 2: {
                    if (lines.length <= 3) {
                        Server.response = "Could not parse input request\nNot enough lines for an add_dasm request.\n";
                        break;
                    }
                    String new_dasm_md5 = lines[1];
                    if (new_dasm_md5.length() != 32) {
                        Server.response = "Could not parse input request\nBad MD5.\n";
                        break;
                    }
                    if (DasmDatabase.get_dasm(new_dasm_md5) != null) {
                        Server.response = "Already known\n";
                        break;
                    }
                    int start_of_disassembly = -1;
                    for (int jj = 2; jj <= 5; jj++) {
                        if (lines[jj].contains("pei-i386")) {
                            start_of_disassembly = jj;
                        }
                    }
                    String[] dasm_lines;
                    if (start_of_disassembly != -1)
                    {
                        dasm_lines = (String[]) Arrays.copyOfRange(lines, start_of_disassembly, lines.length);
                    }
                    else
                    {
                        response = "Could not parse input request\nDoes not appear to be an objdump disassembly of a PE32.\nUse \"objdump -d <input_exe>\"";
                        break;
                    }
                    Dasm new_dasm = DasmHelpers.build_dasm(dasm_lines);

                    DasmDatabase.add_dasm(new_dasm_md5, new_dasm);
                    response = "OK\n";
                    break;
                }
                case 3: {
                    if (lines.length != 1) {
                        Server.response = "Malformed list_dasms request\n";
                        break;
                    }
                    Set<String> md5s = DasmDatabase.get_all_dasm_md5s();
                    Server.response = "";
                    for (String md5 : md5s) {
                        Server.response = Server.response + md5 + "\n";
                    }
                    break;
                }
                case 4: {
                    if (lines.length != 2) {
                        Server.response = "Malformed get_function_entrypoints request\n";
                        break;
                    }
                    String desired_md5 = lines[1];
                    if (desired_md5.length() != 32) {
                        Server.response = "Malformed MD5\n";
                        break;
                    }
                    Dasm dasm = DasmDatabase.get_dasm(desired_md5);
                    if (dasm == null) {
                        Server.response = "Unknown MD5\n";
                        break;
                    }
                    Set<CFG> cfgs = dasm.getCfgs();
                    Server.response = "";
                    for (CFG cfg : cfgs) {
                        Server.response = Server.response + "0x" + Integer.toHexString(cfg.getEntrypoint()) + "\n";
                    }
                    break;
                }
                case 5: {
                    System.out.println("begin to check cfg");
                    if (lines.length != 3) {
                        Server.response = "Malformed get_cfg request\n";
                        break;
                    }
                    String cfg_md5 = lines[1];
                    if (cfg_md5.length() != 32) {
                        Server.response = "Malformed MD5\n";
                          break;
                    }
                    int ep;
                    try {
                        ep = Integer.decode(lines[2]);
                    }
                    catch (NumberFormatException e) {
                        Server.response = "Could not decode desired function entry point.\n";
                          break;
                    }
                    Dasm cfg_dasm = DasmDatabase.get_dasm(cfg_md5);
                    CFG cfg = cfg_dasm.getCFG(ep);
                    if (cfg == null) {
                        Server.response = "Requested function does not exist.\n";
                          break;
                    }
                    Server.response = "";
                    for (BasicBlock block : cfg.get_all_blocks()) {
                        List<Map.Entry<Integer, String>> instructions = block.getInstructions();
                        for (Map.Entry<Integer, String> instr : instructions) {
                            Integer va = instr.getKey();
                            String op = instr.getValue();
                            Server.response = Server.response + "0x" + Integer.toHexString(va) + " : " + op + "\n";
                        }
                        Server.response = Server.response + "SUCCESSORS: ";
                        for (Integer succ : block.getSuccessors()) {
                            Server.response = Server.response + "0x" + Integer.toHexString(succ) + ",";
                        }
                        Server.response = Server.response + "\n-----\n";
                    }
                    break;
                }
                case 6: {
                    if (lines.length != 2) {
                        Server.response = "Malformed query_dasms request\n";
                          break;
                    }
                    String query_md5 = lines[1];
                    if (query_md5.length() != 32) {
                        Server.response = "Malformed MD5";
                          break;
                    }
                    Dasm query_dasm = DasmDatabase.get_dasm(query_md5);
                    if (query_dasm == null) {
                        Server.response = "Desired disassembly does not exist.";
                          break;
                    }
                    NavigableSet<ComparisonResult> dasm_results = DasmDatabase.compute_all_similarities(query_md5);
                    Server.response = "Querying " + query_md5 + "\n";
                    Server.response = Server.response + "Top Five Most Similar:\n";
                    int kk = 0;
                    for (ComparisonResult cr : dasm_results.descendingSet()) {
                        if (kk > 4) break;
                        ++kk;
                        Server.response = Server.response + String.format("%s - Score: %.3f\n", new Object[]{cr.get_md5(), cr.get_score()});
                    }
                    Server.response = Server.response + "\n";
                      break;
                }
                default: {
                    Server.response = "Could not parse input request\n";
lbl210: // 27 sources:
                    break;
                }
            }
        } else if (NanoHTTPD.Method.PUT.equals((Object)method)) {
            int contentLength = Integer.parseInt((String)session.getHeaders().get("content-length"));
            byte[] buffer = new byte[contentLength];
            String new_sample_md5;
            String fv_csv;
            try {
                session.getInputStream().read(buffer, 0, contentLength);
                new_sample_md5 = Server.getMD5Checksum(buffer);
                fv_csv = Server.featurize(buffer);
            }
            catch (Exception e) {
                return Server.newFixedLengthResponse((NanoHTTPD.Response.IStatus)NanoHTTPD.Response.Status.INTERNAL_ERROR, (String)"text/plain", (String)"Error handling HTTP request.\n");
            }
            if (Database.is_unknown(new_sample_md5)) {
                try {
                    Database.see(new_sample_md5);
                    Sample new_sample = new Sample(fv_csv);
                    Database.add_sample(new_sample_md5, new_sample);
                }
                catch (Exception e) {
                    Server.response = "Error, malformed binary input.";
                }
                Server.response = "OK\n";
            } else {
                Server.response = "Already known\n";
            }
        } else {
            Server.response = "Unsupported HTTP request type.\n";
        }
        Logger.write_log_entry(Server.response);
        Logger.close_log();
        System.out.println("My response:" + Server.response);
        return Server.newFixedLengthResponse((NanoHTTPD.Response.IStatus)NanoHTTPD.Response.Status.OK, (String)"text/plain", (String)Server.response.substring(0, Math.min(Server.response.length(), 16000)));
    }
}

